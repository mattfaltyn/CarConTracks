{
  "language": "Solidity",
  "sources": {
    "contracts/CarRental.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\n// test comments \n\ncontract CarRental {\n    // Define state variables\n    address payable rentalOwner;\n    address payable carOwner;\n    uint256 constant public price = 1e17; // 0.1 ETH\n    uint256 public totalCarNum = 0;\n    uint256 private totalUserNumber = 0;\n\n    mapping(address => uint256) public balances;\n\n\n    struct CustomerInfo {\n        bool isValidRental;\n        string customerName;\n        uint customerAge;\n        uint256 licenseID;\n        uint rentDuration;\n        bool hasReturned;\n        bool hasConfirmed;\n    }\n\n    struct CarInfo {\n        bool isAvailable;\n        string carLocation;\n        uint256 carID;\n        uint256 price;\n        string ownerName;\n\n    }\n\n    struct User {\n        string userName;\n        string password;\n        uint256 userID;\n        address payable userAddress;\n        bool isUserLoggedIn;\n    }\n\n    mapping(address => CustomerInfo) public rentals;\n    mapping(uint256 => CarInfo) public cars;\n    mapping(address => User) private users;\n    //mapping(uint256 => address) private caridtocarowner;\n\n    //CarInfo[] carInformation; \n\n    //CustomerInfo storage customer = rentals[rentalOwner];\n    \n\n\n    \n\n    constructor() {\n        rentalOwner = payable(msg.sender);\n        carOwner = payable(address(this));\n\n    }\n\n    // Account creation events\n\n    event accountCreated(\n        User user\n    );\n\n    event LoginDone(User user);\n\n    event LoginFail(string fail);\n\n    // Car Info Events\n\n    event carAdded(\n        uint256 indexed carID,\n        //address payable indexed carOwner,\n        CarInfo car\n    );\n\n    // Rental Events\n\n    event rentalPlaced(     \n        string customerName,\n        uint customerAge,\n        uint256 licenseID,\n        uint256 carID\n    );\n\n    event rentalConfirmed(       \n        string customerName,\n        uint customerAge,\n        uint256 licenseID\n        //uint256 carID\n\n    );\n\n    event rentalCanceled(       \n        string customerName,\n        uint customerAge,\n        uint256 licenseID\n        //uint256 carID\n\n    );\n    event carReturned(       \n        string customerName,\n        uint customerAge,\n        uint256 licenseID\n        //uint256 carID\n\n    );\n\n    // Modifiers\n\n    modifier onlyOwner() {\n        require(msg.sender == rentalOwner, 'only order owner can call this function');\n        _;\n    }\n    // modifier onlyOneRental() {\n    //     require(rentalCount <= 1, 'only one order at a time');\n    //     _;\n    // }\n    modifier existingRental() {\n        require(rentals[rentalOwner].isValidRental == true, 'Please confirm/cancel existing order');\n        _;\n    }\n    modifier unconfirmedRental() {\n        require(rentals[rentalOwner].hasConfirmed == false, 'Cannot cancel confirmed rental');\n        _;\n    }\n    modifier validInfo(string memory _customerName, uint _age, uint256 _licenseID) {\n        require(bytes(_customerName).length > 0  && _age > 0 && _licenseID >0,  'Please enter name, age and license');\n        require(_age >= 18, 'Invalid age');\n        _;\n    }\n    modifier allowNewRental() {\n        require(rentals[rentalOwner].isValidRental == false, 'Please start new rental');\n        _;\n    }\n    modifier enoughAmount(){\n        require(msg.value >= price, 'No enough Ethers');\n        _;\n    }\n    // modifier carAvailable(uint256 _carID){\n    //     require(cars[_carID].isAvailable == true, 'Car is not available.');\n    //     _;\n    // }\n\n    // Account functions\n    function SignUp(address payable _Account, string memory _userName, string memory _password) public returns (bool) {\n        require(_Account != address(0), \"Account can not be empty\");\n        require(users[_Account].userID == 0, \"Account already exists\");\n        require(bytes(_userName).length > 0, \"Please enter a name\");\n        require(bytes(_password).length > 0, \"Please enter a password\");\n        User memory _user;\n        totalUserNumber++;\n        _user.userID = totalUserNumber;\n        _user.userAddress = _Account;\n        _user.userName = _userName;\n        _user.password = _password;\n        _user.isUserLoggedIn = false;\n\n        users[_Account] = _user;\n\n        emit accountCreated(_user);\n        return true;\n    }\n    function Login(address _address, string memory _password) public returns (bool) {\n        User memory _user = users[_address];\n        if (keccak256(abi.encodePacked(_user.password)) ==\n            keccak256(abi.encodePacked(_password))) {\n            _user.isUserLoggedIn = true;\n            emit LoginDone(_user);\n            return _user.isUserLoggedIn;\n        } else {\n            emit LoginFail(\"Incorrect Password\");\n            return false;\n        }\n    }\n    function logout(address _address) public {\n        users[_address].isUserLoggedIn = false;\n    }\n\n\n    // Rentee functions\n\n    function addCar (string memory _carOwner, string memory _carLocation) public returns (bool) {\n        // for (uint i = 0; i < carInformation.length; i++) {\n        //     require(_carID != carInformation[i].carID && _carID > 0, 'Please choose a unique carID' );\n\n        // }\n        require(bytes(_carOwner).length > 0 && bytes(_carLocation).length > 0 ,  'Please enter name and car location');\n        CarInfo memory _car;\n        totalCarNum++;\n        _car.ownerName = _carOwner;\n        _car.carLocation = _carLocation;\n        _car.carID = totalCarNum;\n        _car.isAvailable = true;\n        cars[totalCarNum] = _car;\n        //carInformation.push(_car);\n        //cars[carOwner].push(information);\n\n        emit carAdded(totalCarNum, _car);\n        return true;\n\n    }\n\n    // Rental main functions\n\n    function createRental (string memory _customerName, uint _age, uint256 _licenseID, uint256 _carID) public payable allowNewRental() enoughAmount() validInfo(_customerName, _age, _licenseID) {\n        CarInfo memory _car = cars[_carID];\n        require(_car.isAvailable == true, 'Car is not available.');\n        rentals[rentalOwner].isValidRental = true;\n        rentals[rentalOwner].customerName = _customerName;\n        rentals[rentalOwner].customerAge = _age;\n        rentals[rentalOwner].licenseID = _licenseID;\n        rentals[rentalOwner].hasConfirmed = false;\n        rentals[rentalOwner].hasReturned = false;\n        _car.isAvailable = false;\n\n        //wallet.transfer(msg.value);\n        emit rentalPlaced(rentals[rentalOwner].customerName, rentals[rentalOwner].customerAge, rentals[rentalOwner].licenseID, _carID);\n    }\n    function confirmRental() public existingRental() {\n        rentals[rentalOwner].hasConfirmed = true;\n        // wallet.transfer(msg.value);\n        emit rentalConfirmed(rentals[rentalOwner].customerName, rentals[rentalOwner].customerAge, rentals[rentalOwner].licenseID);\n    }\n\n    function cancelRental() public payable existingRental() unconfirmedRental() {\n        rentals[rentalOwner].hasConfirmed = false;\n        rentals[rentalOwner].isValidRental = false;\n        rentalOwner.transfer(price);\n\n        emit rentalCanceled(rentals[rentalOwner].customerName, rentals[rentalOwner].customerAge, rentals[rentalOwner].licenseID);\n    }\n    function returnCar(uint256 _carID) public existingRental(){\n        rentals[rentalOwner].hasConfirmed = false;\n        rentals[rentalOwner].isValidRental = false;\n        rentals[rentalOwner].hasReturned = true;\n        cars[_carID].isAvailable = true;\n\n        emit carReturned(rentals[rentalOwner].customerName, rentals[rentalOwner].customerAge, rentals[rentalOwner].licenseID);\n    }\n\n\n    // Functions for testing\n\n\n    function getcarAvailability(uint256 _carID) public view returns (bool) {\n        return cars[_carID].isAvailable;\n    }\n    function getorderValidity () public view returns (bool) {\n        return rentals[rentalOwner].isValidRental;\n    }\n    function getorderConfirmation () public view returns (bool) {\n        return rentals[rentalOwner].hasConfirmed;\n    }\n\n    function getorderReturn() public view returns (bool) {\n        return rentals[rentalOwner].hasReturned;\n    }\n    function getcustomerName () public view returns (string memory) {\n        return rentals[rentalOwner].customerName;\n    }\n    function getcustomerAge() public view returns (uint) {\n        return rentals[rentalOwner].customerAge;\n    }\n    function getlicenseID() public view returns (uint256) {\n        return rentals[rentalOwner].licenseID;\n    }\n    function getownerName(uint256 _carID) public view returns (string memory) {\n        return cars[_carID].ownerName;\n    }\n    function getcarLocation(uint256 _carID) public view returns (string memory) {\n        return cars[_carID].carLocation;\n    }\n    function getcarID(uint256 _carID) public view returns (uint256) {\n        return cars[_carID].carID;\n    }\n    function getBalanceofSC() public view returns(uint256) {\n        return carOwner.balance;\n    } \n    function getBalanceofOwner() public view returns(uint256) {\n        return balances[rentalOwner];\n    } \n    \n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}